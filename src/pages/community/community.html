<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Community</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet" />
<link rel="stylesheet" href="/styles/main.css" />
<link rel="stylesheet" href="/styles/components.css" />
  <script type="module" src="/scripts/firebaseauth.js"></script>
  <style>
    :root {
      /* Header variables matching crowd-view */
      --font-size-3xl: 24px;
      --font-size-base: 14px;
      --font-weight-bold: 600;
      --space-32: 32px;
      --space-16: 16px;
      --space-24: 24px;
      --space-8: 8px;
      --color-text-secondary: #666;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background-color: #fafafa;
      color: #1a1a1a;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      padding-top: 70px;
      padding-bottom: 80px;
      overflow-x: hidden;
      width: 100%;
      max-width: 100vw;
    }

    @media (max-width: 768px) {
      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: calc(80px + env(safe-area-inset-bottom));
      }
    }

    /* Desktop View */
    .desktop-view {
      display: block;
      padding: var(--space-32);
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
      min-height: calc(100vh - 150px);
    }

    /* Mobile View */
    .mobile-view {
      display: none;
      padding: var(--space-16);
      padding-top: max(var(--space-16), env(safe-area-inset-top));
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
      overflow-x: hidden;
      min-height: calc(100vh - 150px);
    }

    /* Header styling matching crowd-view */
    .header {
      margin-bottom: var(--space-32);
    }

    .header h1 {
      font-size: var(--font-size-3xl);
      font-weight: var(--font-weight-bold);
      color: #1a1a1a;
      margin-bottom: var(--space-8);
    }

    .header-subtitle {
      font-size: var(--font-size-base);
      color: var(--color-text-secondary);
    }

    .header-search {
      margin-top: 20px;
      width: 100%;
    }

    .search-container {
      position: relative;
      width: 100%;
      max-width: 100%;
      display: flex;
      align-items: center;
      background: white;
      border: 1px solid #1a1a1a;
      border-radius: 6px;
      overflow: hidden;
      box-sizing: border-box;
    }

    .search-container i {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: rgba(26, 26, 26, 0.5);
      pointer-events: none;
      z-index: 1;
      font-size: 16px;
    }

    .search-container input {
      width: 100%;
      padding: 10px 12px 10px 40px;
      border: none;
      border-radius: 6px;
      background: transparent;
      color: #1a1a1a;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.2s;
      box-sizing: border-box;
      outline: none;
    }

    .search-container input::placeholder {
      color: rgba(26, 26, 26, 0.5);
      font-weight: 500;
    }

    .search-container:hover {
      border-color: #4285f4;
      box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.1);
    }

    .search-container:focus-within {
      border-color: #4285f4;
      box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.2);
    }

    .search-container input:focus {
      outline: none;
    }

    /* Post redesign styles */
    .post-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background-color: #ffffff;
    }

    .user-info {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 12px;
    }

    .user-details {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .post-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .post-actions-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px 4px 16px;
      background-color: #ffffff;
    }

    .action-buttons {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 20px;
    }
    
    .bookmark-btn {
      height: 36px;
      width: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 22px;
      padding: 0;
      margin: 0;
    }
    
    .action-group {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }
    
    .action-group .action-btn {
      height: 36px;
      width: 36px;
      font-size: 22px;
      padding: 0;
      margin: 0;
    }

    .action-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      height: 36px;
      width: 36px;
      padding: 0;
      margin: 0;
    }

    .action-count {
      font-size: 14px;
      color: #1a1a1a;
      font-weight: 600;
      line-height: 1;
      text-align: left;
      min-width: 20px;
      display: flex;
      align-items: center;
    }

    .like-btn.liked,
    .like-btn.liked i {
      color: #ff3040 !important;
    }
    
    .like-btn.liked {
      border: 2px solid #000000 !important;
    }

    .bookmark-btn.bookmarked,
    .bookmark-btn.bookmarked i {
      color: #ffc107 !important;
    }
    
    .bookmark-btn.bookmarked {
      border: 2px solid #000000 !important;
    }

    .post-stats {
      display: none;
    }

    .post-caption .caption {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      word-break: break-word;
    }

    .instagram-post {
      cursor: pointer;
      transition: transform 0.2s ease;
      display: flex;
      flex-direction: column;
    }

    .instagram-post:hover {
      transform: translateY(-2px);
    }

    .instagram-feed {
      padding: 0;
      width: 100%;
      min-height: 0;
    }

    .post-image {
      width: 100%;
      height: 400px;
      overflow: hidden;
    }

    .post-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .post-caption {
      padding: 0px 16px 8px 16px;
      margin-top: -4px;
      background-color: #ffffff;
      line-height: 1.5;
      max-height: 60px;
      overflow: hidden;
    }

    /* Responsive - Mobile */
    @media (max-width: 430px) {
      .desktop-view {
        display: none;
      }

      .mobile-view {
        display: block;
      }

      .mobile-view .header {
        margin-bottom: var(--space-24);
        padding: 0 var(--space-16);
        padding-top: var(--space-8);
      }

      .mobile-view .header h1 {
        font-size: 20px;
        margin-bottom: var(--space-8);
      }

      .header-search {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <!-- DESKTOP VIEW -->
  <div class="desktop-view">
    <div class="header">
      <div style="display: flex; justify-content: space-between; align-items: start;">
        <div>
          <h1></i>Community</h1>
          <p class="header-subtitle">Share your hawker food experiences and connect with the community</p>
        </div>
      </div>
      <div class="header-search">
        <div class="search-container">
          <i class="bi bi-search"></i>
          <input type="search" placeholder="Search by username..." id="searchInput" />
        </div>
      </div>
    </div>

    <div id="instagramFeed" class="instagram-feed"></div>
  </div>

  <!-- MOBILE VIEW -->
  <div class="mobile-view">
    <div class="header">
      <div style="display: flex; justify-content: space-between; align-items: start;">
        <div>
          <h1><i class="bi bi-people-fill"></i> Community</h1>
          <p class="header-subtitle">Share your hawker food experiences and connect with the community</p>
        </div>
      </div>
      <div class="header-search">
        <div class="search-container">
          <i class="bi bi-search"></i>
          <input type="search" placeholder="Search by username..." id="searchInputMobile" />
        </div>
      </div>
    </div>

    <div id="instagramFeedMobile" class="instagram-feed"></div>
  </div>

    <div class="nav-bar">
        <a href="/" class="nav-logo"><img src="/img/logo.jpg" alt="ChopeLah" /></a>
        <div class="nav-items">
            <button onclick="location.href='/pages/order/online-order-home.html'">
                <i class="bi bi-cart3"></i>
                <span>Order</span>
            </button>
            <button class="active" onclick="location.href='/pages/community/community.html'">
                <i class="bi bi-people"></i>
                <span>Community</span>
            </button>
            <button onclick="location.href='/pages/chope/chope.html'">
                <i class="bi bi-bookmark"></i>
                <span>Chope</span>
            </button>
            <button onclick="location.href='/pages/crowd/crowd-view.html'">
                <i class="bi bi-eye"></i>
                <span>Crowd View</span>
            </button>
        </div>
        <div class="nav-right">
            <button class="notification-btn" onclick="toggleOrderNotification()">
                <i class="bi bi-bell"></i>
                <span class="notification-badge" style="display: none;">1</span>
            </button>
            <button onclick="location.href='/pages/profile/profile.html'">
                <i class="bi bi-person"></i>
                <span>Profile</span>
            </button>
        </div>
    </div>

<script type="module">
// Expose like sync helpers globally so existing non-module code can call them
import { getAuth } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
import { getFirestore, doc, setDoc, deleteDoc, serverTimestamp, getDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

async function setUserLike(postId, postSnapshot) {
  const auth = getAuth();
  const db = getFirestore();
  const user = auth.currentUser;
  const uid = user?.uid;
  if (!uid) throw new Error('not-authenticated');
  const pid = String(postId);
  const suid = String(uid);
  
  // Check if post already exists in Firestore
  const postRef = doc(db, 'posts', pid);
  const existingPost = await getDoc(postRef);
  
  // Ensure a minimal posts/{postId} exists so Profile can fetch liked posts
  // IMPORTANT: Include createdAt so the post can be queried by orderBy('createdAt')
  const base = {
    updatedAt: serverTimestamp(),
  };
  
  // Only set createdAt if this is a new post
  if (!existingPost.exists()) {
    base.createdAt = serverTimestamp();
    base.authorId = 'sample-user'; // Default for sample posts
  }
  
  if (postSnapshot) {
    base.caption = postSnapshot.caption || postSnapshot.content || '';
    base.mediaUrl = postSnapshot.mediaUrl || null;
    base.authorName = postSnapshot.authorName || postSnapshot.author || '';
    base.authorPhotoURL = postSnapshot.authorPhotoURL || null;
    base.authorId = postSnapshot.authorId || null;
  }
  
  await Promise.all([
    setDoc(postRef, base, { merge: true }),
    setDoc(doc(db, 'users', suid, 'likes', pid), { postId: pid, likedAt: serverTimestamp() }, { merge: true }),
    setDoc(doc(db, 'posts', pid, 'likes', suid), { uid: suid, likedAt: serverTimestamp() }, { merge: true })
  ]);
}

async function unsetUserLike(postId) {
  const auth = getAuth();
  const db = getFirestore();
  const user = auth.currentUser;
  const uid = user?.uid;
  if (!uid) throw new Error('not-authenticated');
  const pid = String(postId);
  const suid = String(uid);
  await Promise.all([
    deleteDoc(doc(db, 'users', suid, 'likes', pid)),
    deleteDoc(doc(db, 'posts', pid, 'likes', suid))
  ]);
}

window.__likeSync = { setUserLike, unsetUserLike };
  </script>

  <script src="/scripts/main.js"></script>
  <script src="/scripts/notification.js"></script>
<script>
// Fallback: Ensure threads are available even if main.js hasn't loaded
// This runs immediately to check if threads exist
(function() {
  // Wait a tiny bit for main.js to execute
  setTimeout(function() {
    if (!window.threads) {
      console.warn('window.threads not set by main.js, trying localStorage...');
      try {
        const stored = localStorage.getItem('threads');
        if (stored) {
          window.threads = JSON.parse(stored);
          console.log('Fallback: Loaded threads from localStorage:', window.threads.length);
        } else {
          console.error('No threads found in localStorage either!');
        }
      } catch (e) {
        console.error('Error in fallback thread loading:', e);
      }
    } else {
      console.log('Threads available from main.js:', window.threads.length);
    }
  }, 50);
})();
</script>
<script type="module">
import { getAuth } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
import { getFirestore, collection, query, orderBy, limit, getDocs, doc, setDoc, deleteDoc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";
import { getStorage, ref, deleteObject } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-storage.js";

// Wait for Firebase to initialize before using it
let auth, db, storage;
const feed = document.getElementById('instagramFeed');
let likeCounts = {}; // Will be loaded from Firestore per user
let followStatus = {}; // Will be loaded from Firestore per user
let bookmarkStatus = {}; // Will be loaded from Firestore per user

// Initialize Firebase instances - wait for firebaseauth.js to finish
async function initFirebase() {
  try {
    // Wait for Firebase to be initialized by firebaseauth.js
    if (window.firebaseInitPromise) {
      await window.firebaseInitPromise;
      console.log('Firebase initialization promise resolved');
    } else {
      // If promise doesn't exist, wait a bit for firebaseauth.js to load
      console.log('Waiting for firebaseauth.js to initialize...');
      let attempts = 0;
      while (!window.firebaseInitPromise && attempts < 20) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }
      if (window.firebaseInitPromise) {
        await window.firebaseInitPromise;
      }
    }
    
    // Use window.auth and window.db if available (set by firebaseauth.js)
    if (window.auth && window.db && window.app) {
      auth = window.auth;
      db = window.db;
      storage = getStorage(window.app, "gs://wad2-login-5799b.firebasestorage.app");
      console.log('Using Firebase instances from firebaseauth.js');
    } else {
      // Fallback: try to get from default app
      const { getApp } = await import("https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js");
      const app = getApp();
      auth = getAuth(app);
      db = getFirestore(app);
      storage = getStorage(app, "gs://wad2-login-5799b.firebasestorage.app");
      console.log('Created Firebase instances from default app');
    }
  } catch (error) {
    console.error('Error initializing Firebase:', error);
    // Try to continue with default app anyway
    try {
      const { getApp } = await import("https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js");
      const app = getApp();
      auth = getAuth(app);
      db = getFirestore(app);
      storage = getStorage(app, "gs://wad2-login-5799b.firebasestorage.app");
    } catch (e) {
      console.error('Failed to initialize Firebase:', e);
      throw e;
    }
  }
}

// Track current user's likes from Firestore
let userLikes = new Set();

async function renderInstagramFeed() {
  console.log('renderInstagramFeed called');
  if (!feed) {
    console.error('Feed element not found!');
    return;
  }
  
  feed.innerHTML = '';

  // Load current user's likes, follows, and bookmarks from Firestore
  try {
    await loadUserLikes();
    await loadUserFollows();
    await loadUserBookmarks();
  } catch (e) {
    console.error('Error loading user data:', e);
    // Continue anyway - we can still show posts
  }

  // Render Firestore posts first (new, permanent posts)
  try {
    const postsRef = collection(db, 'posts');
    const qy = query(postsRef, orderBy('createdAt', 'desc'), limit(30));
    const snap = await getDocs(qy);
    console.log(`Loaded ${snap.docs.length} posts from Firestore`);
    const firePosts = snap.docs.map(d => {
      const data = d.data();
      return {
        id: d.id,
        author: (data.authorName || 'User'),
        authorPhotoURL: data.authorPhotoURL || null, // Profile picture URL from post
        authorId: data.authorId || null, // User ID for loading profile if needed
        content: (data.caption || ''),
        mediaUrl: (data.mediaUrl || null),
        comments: []
      };
    });
    // Render posts (renderOne is async but we don't need to wait)
    firePosts.forEach(thread => renderOne(thread).catch(e => console.error('Error rendering post:', e)));
  } catch (e) {
    console.error('Failed to load Firestore posts', e);
    // Continue to load sample threads even if Firestore fails
  }

  // Then render local sample threads
  // Load threads from window (set by main.js) or localStorage as fallback
  let sampleThreads = window.threads;
  console.log('window.threads available:', !!sampleThreads);
  
  if (!sampleThreads) {
    try {
      const stored = localStorage.getItem('threads');
      console.log('localStorage threads available:', !!stored);
      if (stored) {
        sampleThreads = JSON.parse(stored);
        window.threads = sampleThreads; // Cache for future use
        console.log(`Loaded ${sampleThreads.length} threads from localStorage`);
      } else {
        console.warn('No threads found in localStorage or window.threads');
        sampleThreads = [];
      }
    } catch (e) {
      console.error('Failed to load threads from localStorage:', e);
      sampleThreads = [];
    }
  } else {
    console.log(`Using ${sampleThreads.length} threads from window.threads`);
  }
  
  if (sampleThreads && Array.isArray(sampleThreads) && sampleThreads.length > 0) {
    console.log(`Rendering ${sampleThreads.length} sample threads`);
    // Render sample threads (renderOne is async but we don't need to wait)
    sampleThreads.forEach(thread => renderOne(thread).catch(e => console.error('Error rendering post:', e)));
  } else {
    console.warn('threads is not a valid array or is empty, skipping sample threads');
    console.warn('sampleThreads value:', sampleThreads);
  }
  
  // Check if any posts were rendered
  const renderedPosts = document.querySelectorAll('.instagram-post');
  console.log(`Total posts rendered: ${renderedPosts.length}`);
  
  if (renderedPosts.length === 0) {
    console.warn('No posts were rendered!');
    feed.innerHTML = '<div style="padding: 40px; text-align: center; color: #666;"><p>No posts to display.</p><p style="font-size: 0.9em; margin-top: 10px;">Check the console for details.</p></div>';
  }

  // Handle deep link: ?postId=...&open=comments
  try {
    const params = new URLSearchParams(window.location.search);
    const pid = params.get('postId');
    const open = params.get('open');
    if (pid) {
      const el = document.getElementById(`post-${pid}`);
      if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        if (open === 'comments') {
          const commentBtn = el.querySelector('.comment-btn');
          if (commentBtn) commentBtn.click();
        }
      }
    }
  } catch (_) {}
}

// Load current user's likes and like counts from Firestore
async function loadUserLikes() {
  try {
    const user = auth.currentUser;
    if (!user) {
      console.log('No user logged in, skipping like loading');
      userLikes.clear();
      likeCounts = {};
      return;
    }
    
    console.log('Loading likes for user:', user.uid);
    
    // Load user's liked posts
    const likesRef = collection(db, 'users', user.uid, 'likes');
    const likesSnap = await getDocs(likesRef);
    userLikes.clear();
    likeCounts = {};
    
    console.log(`User has ${likesSnap.size} likes in their collection`);
    
    // Count likes for each post by checking posts/{postId}/likes subcollections
    const postsRef = collection(db, 'posts');
    const postsSnap = await getDocs(postsRef);
    
    for (const postDoc of postsSnap.docs) {
      const postId = postDoc.id;
      const likesSubRef = collection(db, 'posts', postId, 'likes');
      const likesSubSnap = await getDocs(likesSubRef);
      likeCounts[postId] = likesSubSnap.size;
      
      // Check if current user liked this post
      const userLikeDoc = likesSubSnap.docs.find(doc => doc.id === user.uid);
      if (userLikeDoc) {
        userLikes.add(postId);
      }
    }
    
    // Also check likes for sample threads (local data)
    const sampleThreads = window.threads || [];
    for (const thread of sampleThreads) {
      if (!likeCounts[thread.id]) {
        const likesSubRef = collection(db, 'posts', thread.id, 'likes');
        const likesSubSnap = await getDocs(likesSubRef);
        likeCounts[thread.id] = likesSubSnap.size;
        
        const userLikeDoc = likesSubSnap.docs.find(doc => doc.id === user.uid);
        if (userLikeDoc) {
          userLikes.add(thread.id);
        }
      }
    }
    
    console.log('Likes loaded:', Array.from(userLikes));
    console.log('Like counts:', likeCounts);
  } catch (e) {
    console.error('Failed to load user likes', e);
    userLikes.clear();
    likeCounts = {};
  }
}

// Load current user's follow status from Firestore
async function loadUserFollows() {
  try {
    const user = auth.currentUser;
    if (!user) {
      followStatus = {};
      return;
    }
    
    // Load user's followed authors
    const followsRef = collection(db, 'users', user.uid, 'follows');
    const followsSnap = await getDocs(followsRef);
    followStatus = {};
    
    followsSnap.docs.forEach(docSnap => {
      const authorName = docSnap.id; // Document ID is the author name
      followStatus[authorName] = true;
    });
    
    console.log('Follows loaded:', followStatus);
  } catch (e) {
    console.error('Failed to load user follows', e);
    followStatus = {};
  }
}

// Load current user's bookmark status from Firestore
async function loadUserBookmarks() {
  try {
    const user = auth.currentUser;
    if (!user) {
      bookmarkStatus = {};
      return;
    }
    
    // Load user's bookmarked posts
    const bookmarksRef = collection(db, 'users', user.uid, 'bookmarks');
    const bookmarksSnap = await getDocs(bookmarksRef);
    bookmarkStatus = {};
    
    bookmarksSnap.docs.forEach(docSnap => {
      const postId = docSnap.id; // Document ID is the post ID
      bookmarkStatus[postId] = true;
    });
    
    console.log('Bookmarks loaded:', bookmarkStatus);
  } catch (e) {
    console.error('Failed to load user bookmarks', e);
    bookmarkStatus = {};
  }
}

async function renderOne(thread) {
  const postElement = document.createElement('div');
  postElement.className = 'instagram-post fade-in';
  postElement.id = `post-${thread.id}`;
  
  // Use Firestore like status if available, fallback to localStorage
  const isLikedByUser = userLikes.has(thread.id);
  const likeCount = likeCounts[thread.id] || 0;
  const isFollowing = followStatus[thread.author] || false;
  const isBookmarked = bookmarkStatus[thread.id] || false;
  
  // Check if current user owns this post
  const currentUser = auth ? auth.currentUser : null;
  const isOwnPost = currentUser && thread.authorId && thread.authorId === currentUser.uid;
  
  // Load profile picture - use authorPhotoURL from post if available, otherwise try to load from user document
  let authorPhotoURL = thread.authorPhotoURL || null;
  if (!authorPhotoURL && thread.authorId && db) {
    try {
      const userDocRef = doc(db, 'users', thread.authorId);
      const userDocSnap = await getDoc(userDocRef);
      if (userDocSnap.exists()) {
        const userData = userDocSnap.data();
        authorPhotoURL = userData.photoURL || null;
        // Also update author name if username is available
        if (userData.username && !thread.author.startsWith('@')) {
          thread.author = userData.username;
        }
      }
    } catch (e) {
      console.warn('Failed to load author profile picture:', e);
    }
  }
  
  // Create avatar HTML - show profile picture if available, otherwise show initial
  const avatarInitial = thread.author.charAt(0).toUpperCase();
  const avatarHTML = authorPhotoURL 
    ? `<div class="avatar" style="background-image: url('${authorPhotoURL}'); background-size: cover; background-position: center; background-repeat: no-repeat; color: transparent; text-indent: -9999px;">${avatarInitial}</div>`
    : `<div class="avatar">${avatarInitial}</div>`;
    
    postElement.innerHTML = `
      <div class="post-header">
        <div class="user-info">
          ${avatarHTML}
          <div class="user-details">
            <span class="username">${thread.author}</span>
          </div>
        </div>
        <div class="post-actions">
          <button class="follow-btn ${isFollowing ? 'following' : ''}" data-user="${thread.author}">
            <i class="bi bi-${isFollowing ? 'person-check-fill' : 'person-plus'}"></i>
            ${isFollowing ? 'Following' : 'Follow'}
          </button>
          ${isOwnPost ? `
            <div class="more-menu-wrapper" style="position: relative;">
              <button class="more-btn" data-post-id="${thread.id}">
                <i class="bi bi-three-dots"></i>
              </button>
              <div class="more-menu" id="more-menu-${thread.id}" style="display: none; position: absolute; right: 0; top: 100%; background: white; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 1000; min-width: 150px; margin-top: 4px;">
                <button class="delete-post-btn" data-post-id="${thread.id}" data-author-id="${thread.authorId || ''}" style="width: 100%; padding: 12px 16px; text-align: left; border: none; background: none; cursor: pointer; color: #dc3545; font-size: 14px; border-radius: 8px;">
                  <i class="bi bi-trash"></i> Delete Post
                </button>
              </div>
            </div>
          ` : ''}
        </div>
      </div>
      
      <div class="post-image">
        ${thread.mediaUrl ? `<img src="${thread.mediaUrl}" alt="post" class="w-100">` : '<div class="image-placeholder"></div>'}
      </div>
      
      <div class="post-actions-bar">
        <div class="action-buttons">
          <div class="action-group">
            <span class="action-count like-count">${likeCount}</span>
            <button class="action-btn like-btn ${isLikedByUser ? 'liked' : ''}" data-post-id="${thread.id}">
              <i class="bi bi-heart${isLikedByUser ? '-fill' : ''}"></i>
            </button>
          </div>
          <div class="action-group">
            <span class="action-count comment-count">${thread.comments.length}</span>
            <button class="action-btn comment-btn" data-post-id="${thread.id}">
              <i class="bi bi-chat"></i>
            </button>
          </div>
        </div>
        <button class="action-btn bookmark-btn ${isBookmarked ? 'bookmarked' : ''}" data-post-id="${thread.id}">
          <i class="bi bi-bookmark${isBookmarked ? '-fill' : ''}"></i>
        </button>
      </div>
      
      <div class="post-caption">
        <span class="caption">${thread.content || 'Beautiful moment captured! ✨'}</span>
      </div>
      
      <div class="comments-section" id="comments-${thread.id}" style="display: none;">
        <div class="comments-list">
          ${thread.comments.map((comment, commentIndex) => `
            <div class="comment-item" data-comment-index="${commentIndex}">
              <div class="comment-content">
                <span class="comment-author">${comment.author}</span>
                <span class="comment-text">${comment.content}</span>
              </div>
              <div class="comment-actions">
                <button class="comment-like-btn">
                  <i class="bi bi-heart"></i>
                </button>
                ${comment.author === "You" ? `<button class="delete-comment-btn"><i class="bi bi-trash"></i></button>` : ''}
              </div>
            </div>
          `).join('')}
        </div>
        
        <div class="add-comment">
          <input type="text" placeholder="Add a comment..." class="comment-input" data-post-id="${thread.id}" />
          <button class="post-comment-btn" data-post-id="${thread.id}">
            <i class="bi bi-send"></i>
          </button>
        </div>
      </div>
    `;
    
  feed.appendChild(postElement);
  setupPostInteractions(postElement, thread);
  
  // Set up real-time comment count listener for this post
  setupCommentCountListenerForPost(postElement, thread.id);
  
  // Make post clickable to navigate to detail page
  postElement.addEventListener('click', function(e) {
    // Don't navigate if clicking on buttons or interactive elements
    if (e.target.closest('.action-btn') || 
        e.target.closest('.follow-btn') || 
        e.target.closest('.more-btn') ||
        e.target.closest('.more-menu') ||
        e.target.closest('.comments-section')) {
      return;
    }
    // Navigate to detail page
    window.location.href = `/pages/community/post-detail.html?id=${thread.id}`;
  });
}

function setupPostInteractions(postElement, thread) {
  // Like functionality
  const likeBtn = postElement.querySelector('.like-btn');
  const likeCount = postElement.querySelector('.like-count');
  
  likeBtn.addEventListener('click', async function() {
    const postId = thread.id;
    const isLiked = this.classList.contains('liked');
    
    // Update UI immediately
    if (isLiked) {
      likeCounts[postId] = Math.max(0, (likeCounts[postId] || 0) - 1);
      this.classList.remove('liked');
      this.querySelector('i').className = 'bi bi-heart';
      userLikes.delete(postId);
    } else {
      likeCounts[postId] = (likeCounts[postId] || 0) + 1;
      this.classList.add('liked');
      this.querySelector('i').className = 'bi bi-heart-fill';
      this.style.animation = 'heartPulse 0.6s ease-in-out';
      setTimeout(() => this.style.animation = '', 600);
      userLikes.add(postId);
    }
    
    // Don't save to localStorage anymore - counts are managed in Firestore
    likeCount.textContent = likeCounts[postId];

    // Sync to Firestore likes so it appears in Profile > Liked
    if (window.__likeSync) {
      const op = isLiked ? window.__likeSync.unsetUserLike : window.__likeSync.setUserLike;
      const snapshot = { 
        authorName: thread.author, 
        caption: thread.content || '', 
        mediaUrl: thread.mediaUrl || null,
        authorPhotoURL: thread.authorPhotoURL || null,
        authorId: thread.authorId || null
      };
      try {
        await op(postId, snapshot);
      } catch (e) {
        if (e && e.message === 'not-authenticated') {
          alert('Please sign in to like posts.');
          // Revert UI changes
          if (isLiked) {
            likeCounts[postId] = (likeCounts[postId] || 0) + 1;
            this.classList.add('liked');
            this.querySelector('i').className = 'bi bi-heart-fill';
            userLikes.add(postId);
          } else {
            likeCounts[postId] = Math.max(0, (likeCounts[postId] || 0) - 1);
            this.classList.remove('liked');
            this.querySelector('i').className = 'bi bi-heart';
            userLikes.delete(postId);
          }
          likeCount.textContent = likeCounts[postId];
        } else {
          console.error('Like sync failed', e);
        }
      }
    }
  });
  
  // Follow functionality
  const followBtn = postElement.querySelector('.follow-btn');
  followBtn.addEventListener('click', async function() {
    const authorName = this.dataset.user;
    const isFollowing = this.classList.contains('following');
    const currentUser = auth.currentUser;
    
    if (!currentUser) {
      alert('Please sign in to follow users.');
      return;
    }
    
    try {
      if (isFollowing) {
        // Unfollow: remove from Firestore
        await deleteDoc(doc(db, 'users', currentUser.uid, 'follows', authorName));
        followStatus[authorName] = false;
        this.classList.remove('following');
        this.innerHTML = '<i class="bi bi-person-plus"></i> Follow';
      } else {
        // Follow: add to Firestore
        await setDoc(doc(db, 'users', currentUser.uid, 'follows', authorName), {
          authorName: authorName,
          followedAt: new Date()
        });
        followStatus[authorName] = true;
        this.classList.add('following');
        this.innerHTML = '<i class="bi bi-person-check-fill"></i> Following';
      }
    } catch (e) {
      console.error('Follow action failed', e);
      alert('Could not update follow status. Please try again.');
    }
  });
  
  // Bookmark functionality
  const bookmarkBtn = postElement.querySelector('.bookmark-btn');
  bookmarkBtn.addEventListener('click', async function() {
    const postId = thread.id;
    const isBookmarked = this.classList.contains('bookmarked');
    const currentUser = auth.currentUser;
    
    if (!currentUser) {
      alert('Please sign in to bookmark posts.');
      return;
    }
    
    try {
      if (isBookmarked) {
        // Remove bookmark from Firestore
        await deleteDoc(doc(db, 'users', currentUser.uid, 'bookmarks', postId));
        bookmarkStatus[postId] = false;
        this.classList.remove('bookmarked');
        this.querySelector('i').className = 'bi bi-bookmark';
      } else {
        // Add bookmark to Firestore
        await setDoc(doc(db, 'users', currentUser.uid, 'bookmarks', postId), {
          postId: postId,
          bookmarkedAt: new Date(),
          authorName: thread.author,
          caption: thread.content || '',
          mediaUrl: thread.mediaUrl || null
        });
        bookmarkStatus[postId] = true;
        this.classList.add('bookmarked');
        this.querySelector('i').className = 'bi bi-bookmark-fill';
      }
    } catch (e) {
      console.error('Bookmark action failed', e);
      alert('Could not update bookmark status. Please try again.');
    }
  });
  
  // More menu toggle (only for own posts)
  const moreBtn = postElement.querySelector('.more-btn');
  const moreMenu = postElement.querySelector('.more-menu');
  if (moreBtn && moreMenu) {
    // Close menu when clicking outside
    document.addEventListener('click', function(e) {
      if (!moreBtn.contains(e.target) && !moreMenu.contains(e.target)) {
        moreMenu.style.display = 'none';
      }
    });
    
    moreBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      // Close all other menus
      document.querySelectorAll('.more-menu').forEach(menu => {
        if (menu.id !== moreMenu.id) {
          menu.style.display = 'none';
        }
      });
      moreMenu.style.display = moreMenu.style.display === 'none' ? 'block' : 'none';
    });
  }
  
  // Delete post functionality
  const deleteBtn = postElement.querySelector('.delete-post-btn');
  if (deleteBtn) {
    deleteBtn.addEventListener('click', async function(e) {
      e.stopPropagation();
      const postId = thread.id;
      
      if (!confirm('Are you sure you want to delete this post? This action cannot be undone.')) {
        return;
      }
      
      const currentUser = auth.currentUser;
      if (!currentUser) {
        alert('Please sign in to delete posts.');
        return;
      }
      
      // Verify user owns the post
      const authorId = deleteBtn.dataset.authorId || thread.authorId;
      if (authorId !== currentUser.uid) {
        alert('You can only delete your own posts.');
        return;
      }
      
      try {
        deleteBtn.disabled = true;
        deleteBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Deleting...';
        
        // Delete image from Firebase Storage if it exists
        if (thread.mediaUrl && thread.mediaUrl.includes('firebasestorage.googleapis.com')) {
          try {
            // Extract the path from the URL
            const urlParts = thread.mediaUrl.split('/o/');
            if (urlParts.length > 1) {
              const pathPart = urlParts[1].split('?')[0];
              const decodedPath = decodeURIComponent(pathPart);
              const storageRef = ref(storage, decodedPath);
              await deleteObject(storageRef);
              console.log('✅ Deleted image from Storage');
            }
          } catch (storageError) {
            console.warn('⚠️ Could not delete image from Storage:', storageError);
            // Continue with post deletion even if image deletion fails
          }
        }
        
        // Delete all likes on this post
        const likesRef = collection(db, 'posts', postId, 'likes');
        const likesSnap = await getDocs(likesRef);
        const deleteLikesPromises = likesSnap.docs.map(likeDoc => deleteDoc(likeDoc.ref));
        await Promise.all(deleteLikesPromises);
        
        // Delete all user bookmarks for this post
        const bookmarksQuery = query(collection(db, 'users'), where('bookmarks', 'array-contains', postId));
        // Note: This is a simplified approach. In a real app, you'd need to query all users' bookmarks subcollections
        // For now, we'll delete from current user's bookmarks and others will be cleaned up over time
        
        // Delete from all users' likes (users/{uid}/likes/{postId})
        // This requires iterating through all users, which is not efficient
        // For now, we'll just delete from the post's likes subcollection (already done above)
        
        // Delete the post document
        await deleteDoc(doc(db, 'posts', postId));
        
        // Remove from UI with fade out animation
        postElement.style.transition = 'opacity 0.3s ease';
        postElement.style.opacity = '0';
        setTimeout(() => {
          postElement.remove();
          
          // Check if feed is now empty
          const feed = document.getElementById('instagramFeed');
          if (feed && feed.children.length === 0) {
            feed.innerHTML = '<div style="padding: 40px; text-align: center; color: #666;"><p>No posts to display.</p></div>';
          }
        }, 300);
        
        console.log('✅ Post deleted successfully');
      } catch (error) {
        console.error('❌ Error deleting post:', error);
        alert('Failed to delete post. Please try again.');
        deleteBtn.disabled = false;
        deleteBtn.innerHTML = '<i class="bi bi-trash"></i> Delete Post';
      }
    });
  }
  
  // Comment button - navigate to post detail page
  const commentBtn = postElement.querySelector('.comment-btn');
  
  commentBtn.addEventListener('click', function(e) {
    e.stopPropagation(); // Prevent triggering the post click handler
    // Navigate to detail page with comments open
    window.location.href = `/pages/community/post-detail.html?id=${thread.id}&open=comments`;
  });
}

function setupCommentCountListenerForPost(postElement, postId) {
  const commentCountElement = postElement.querySelector('.comment-count');
  if (!commentCountElement) return;
  
  // Listen to comments collection changes
  try {
    const commentsRef = collection(db, 'posts', postId, 'comments');
    const unsubscribe = onSnapshot(commentsRef, (snapshot) => {
      const count = snapshot.size;
      if (commentCountElement) {
        commentCountElement.textContent = count;
      }
    }, (error) => {
      // Silently fail if comments collection doesn't exist yet
      if (error.code !== 'permission-denied') {
        console.error('Error listening to comments for post', postId, ':', error);
      }
    });
    
    // Store unsubscribe function on the post element for cleanup
    postElement._commentListenerUnsubscribe = unsubscribe;
  } catch (e) {
    // If collection doesn't exist or other error, just ignore
    console.log('Could not set up comment listener for post', postId);
  }
}

function setupCommentInteractions(commentItem, thread) {
  // Comment like functionality
  const commentLikeBtn = commentItem.querySelector('.comment-like-btn');
  commentLikeBtn.addEventListener('click', function() {
    this.classList.toggle('liked');
    const icon = this.querySelector('i');
    icon.className = this.classList.contains('liked') ? 'bi bi-heart-fill' : 'bi bi-heart';
  });
  
  // Delete comment functionality
  const deleteBtn = commentItem.querySelector('.delete-comment-btn');
  if (deleteBtn) {
    deleteBtn.addEventListener('click', function() {
      const commentIndex = parseInt(commentItem.dataset.commentIndex);
      thread.comments.splice(commentIndex, 1);
      // Update threads in both window and localStorage
      if (window.threads) {
        const threadIndex = window.threads.findIndex(t => t.id === thread.id);
        if (threadIndex !== -1) {
          window.threads[threadIndex] = thread;
        }
        localStorage.setItem('threads', JSON.stringify(window.threads));
      }
      commentItem.remove();
      
      // Update comment count
      const postElement = commentItem.closest('.instagram-post');
      const commentCount = postElement.querySelector('.comment-count');
      commentCount.textContent = thread.comments.length;
    });
  }
}

// Search functionality - searches by username only (starts with, case-insensitive)
document.getElementById('searchInput').addEventListener('input', function() {
  const searchTerm = this.value.toLowerCase().trim();
  const posts = document.querySelectorAll('.instagram-post');
  
  posts.forEach(post => {
    const username = post.querySelector('.username').textContent.toLowerCase();
    // Only show posts where username starts with search term (case-insensitive)
    const isVisible = searchTerm === '' || username.startsWith(searchTerm);
    post.style.display = isVisible ? 'block' : 'none';
  });
});

// Initialize the feed AFTER auth is ready
// This ensures likes/follows/bookmarks load correctly
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";

let feedInitialized = false;

// Function to initialize feed with proper error handling
async function initializeFeed() {
  if (feedInitialized) return;
  
  try {
    // Ensure Firebase is initialized first
    if (!auth || !db) {
      console.log('Initializing Firebase...');
      await initFirebase();
    }
    
    // Ensure threads are loaded - wait a bit if main.js hasn't executed yet
    if (!window.threads) {
      // Try loading from localStorage immediately
      try {
        const stored = localStorage.getItem('threads');
        if (stored) {
          window.threads = JSON.parse(stored);
          console.log('Loaded threads from localStorage:', window.threads.length);
        }
      } catch (e) {
        console.error('Error loading from localStorage:', e);
      }
      
      // If still not available, wait a bit for main.js to load
      if (!window.threads) {
        console.warn('window.threads not available, waiting for main.js...');
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Try localStorage again after wait
        try {
          const stored = localStorage.getItem('threads');
          if (stored) {
            window.threads = JSON.parse(stored);
            console.log('Loaded threads from localStorage after wait:', window.threads.length);
          }
        } catch (e) {
          console.error('Error loading from localStorage after wait:', e);
        }
      }
    }
    
    feedInitialized = true;
    await renderInstagramFeed();
    console.log('Feed initialized successfully');
  } catch (error) {
    console.error('Error initializing feed:', error);
    // Still try to render even if there's an error
    if (!feedInitialized) {
      feedInitialized = true;
      try {
        await renderInstagramFeed();
      } catch (e) {
        console.error('Failed to render feed after error:', e);
        // Show error message to user
        if (feed) {
          feed.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Unable to load feed. Please refresh the page.</div>';
        }
      }
    }
  }
}

// Initialize when auth state changes
// Wait for Firebase to be ready first
initFirebase().then(() => {
  if (auth) {
    onAuthStateChanged(auth, async (user) => {
      await initializeFeed();
    });
  } else {
    console.error('Auth not available, initializing feed without auth...');
    initializeFeed();
  }
}).catch(error => {
  console.error('Failed to initialize Firebase, initializing feed anyway:', error);
  initializeFeed();
});

// Fallback: Also try to initialize after a short delay in case auth is slow
// This ensures the feed renders even if auth takes too long
setTimeout(async () => {
  if (!feedInitialized) {
    console.log('Auth state change timeout, initializing feed anyway...');
    await initializeFeed();
  }
}, 1000);

// Additional fallback: Ensure DOM is ready and check if feed needs initialization
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', async () => {
    console.log('DOMContentLoaded fired, checking feed initialization...');
    if (!feedInitialized) {
      console.log('Feed not initialized on DOMContentLoaded, initializing now...');
      await initializeFeed();
    }
  });
} else {
  // DOM is already ready
  setTimeout(async () => {
    if (!feedInitialized) {
      console.log('DOM already ready, but feed not initialized, trying again...');
      await initializeFeed();
    }
  }, 500);
}
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
