<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Community</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet" />
<link rel="stylesheet" href="/styles/main.css" />
<link rel="stylesheet" href="/styles/components.css" />
  <script type="module" src="/scripts/firebaseauth.js"></script>
</head>
<body>
<div class="instagram-container">
  <div class="instagram-header">
    <h1><i class="bi bi-people-fill"></i> Community</h1>
    <div class="search-container">
      <i class="bi bi-search"></i>
      <input type="search" placeholder="Search posts..." id="searchInput" />
    </div>
  </div>

  <div id="instagramFeed" class="instagram-feed"></div>
</div>

    <div class="nav-bar">
        <a href="/" class="nav-logo"><i class="bi bi-shop"></i>ChopeLah</a>
        <div class="nav-items">
            <button onclick="location.href='/pages/order/online-order-home.html'">
                <i class="bi bi-cart3"></i>
                <span>Order</span>
            </button>
            <button class="active" onclick="location.href='/pages/community/community.html'">
                <i class="bi bi-people"></i>
                <span>Community</span>
            </button>
            <button onclick="location.href='/pages/chope/chope.html'">
                <i class="bi bi-bookmark"></i>
                <span>Chope</span>
            </button>
            <button onclick="location.href='/pages/crowd/crowd-view.html'">
                <i class="bi bi-eye"></i>
                <span>Crowd View</span>
            </button>
        </div>
        <div class="nav-right">
            <button class="notification-btn" onclick="alert('No new notifications')">
                <i class="bi bi-bell"></i>
                <span class="notification-badge">3</span>
            </button>
            <button onclick="location.href='/pages/profile/profile.html'">
                <i class="bi bi-person"></i>
                <span>Profile</span>
            </button>
        </div>
    </div>

<script type="module">
// Expose like sync helpers globally so existing non-module code can call them
import { getAuth } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
import { getFirestore, doc, setDoc, deleteDoc, serverTimestamp, getDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

async function setUserLike(postId, postSnapshot) {
  const auth = getAuth();
  const db = getFirestore();
  const user = auth.currentUser;
  const uid = user?.uid;
  if (!uid) throw new Error('not-authenticated');
  const pid = String(postId);
  const suid = String(uid);
  
  // Check if post already exists in Firestore
  const postRef = doc(db, 'posts', pid);
  const existingPost = await getDoc(postRef);
  
  // Ensure a minimal posts/{postId} exists so Profile can fetch liked posts
  // IMPORTANT: Include createdAt so the post can be queried by orderBy('createdAt')
  const base = {
    updatedAt: serverTimestamp(),
  };
  
  // Only set createdAt if this is a new post
  if (!existingPost.exists()) {
    base.createdAt = serverTimestamp();
    base.authorId = 'sample-user'; // Default for sample posts
  }
  
  if (postSnapshot) {
    base.caption = postSnapshot.caption || postSnapshot.content || '';
    base.mediaUrl = postSnapshot.mediaUrl || null;
    base.authorName = postSnapshot.authorName || postSnapshot.author || '';
  }
  
  await Promise.all([
    setDoc(postRef, base, { merge: true }),
    setDoc(doc(db, 'users', suid, 'likes', pid), { postId: pid, likedAt: serverTimestamp() }, { merge: true }),
    setDoc(doc(db, 'posts', pid, 'likes', suid), { uid: suid, likedAt: serverTimestamp() }, { merge: true })
  ]);
}

async function unsetUserLike(postId) {
  const auth = getAuth();
  const db = getFirestore();
  const user = auth.currentUser;
  const uid = user?.uid;
  if (!uid) throw new Error('not-authenticated');
  const pid = String(postId);
  const suid = String(uid);
  await Promise.all([
    deleteDoc(doc(db, 'users', suid, 'likes', pid)),
    deleteDoc(doc(db, 'posts', pid, 'likes', suid))
  ]);
}

window.__likeSync = { setUserLike, unsetUserLike };
</script>

<script src="/scripts/main.js"></script>
<script type="module">
import { getAuth } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
import { getFirestore, collection, query, orderBy, limit, getDocs, doc, setDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";
// Instagram-style feed functionality
const auth = getAuth();
const db = getFirestore();
const feed = document.getElementById('instagramFeed');
let likeCounts = {}; // Will be loaded from Firestore per user
let followStatus = {}; // Will be loaded from Firestore per user
let bookmarkStatus = {}; // Will be loaded from Firestore per user

// Track current user's likes from Firestore
let userLikes = new Set();

async function renderInstagramFeed() {
  feed.innerHTML = '';

  // Load current user's likes, follows, and bookmarks from Firestore
  await loadUserLikes();
  await loadUserFollows();
  await loadUserBookmarks();

  // Render Firestore posts first (new, permanent posts)
  try {
    const postsRef = collection(db, 'posts');
    const qy = query(postsRef, orderBy('createdAt', 'desc'), limit(30));
    const snap = await getDocs(qy);
    const firePosts = snap.docs.map(d => ({
      id: d.id,
      author: (d.data().authorName || 'User'),
      content: (d.data().caption || ''),
      mediaUrl: (d.data().mediaUrl || null),
      comments: []
    }));
    firePosts.forEach(renderOne);
  } catch (e) {
    console.error('Failed to load Firestore posts', e);
  }

  // Then render local sample threads
  threads.forEach(renderOne);

  // Handle deep link: ?postId=...&open=comments
  try {
    const params = new URLSearchParams(window.location.search);
    const pid = params.get('postId');
    const open = params.get('open');
    if (pid) {
      const el = document.getElementById(`post-${pid}`);
      if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
        if (open === 'comments') {
          const commentBtn = el.querySelector('.comment-btn');
          if (commentBtn) commentBtn.click();
        }
      }
    }
  } catch (_) {}
}

// Load current user's likes and like counts from Firestore
async function loadUserLikes() {
  try {
    const user = auth.currentUser;
    if (!user) {
      console.log('No user logged in, skipping like loading');
      userLikes.clear();
      likeCounts = {};
      return;
    }
    
    console.log('Loading likes for user:', user.uid);
    
    // Load user's liked posts
    const likesRef = collection(db, 'users', user.uid, 'likes');
    const likesSnap = await getDocs(likesRef);
    userLikes.clear();
    likeCounts = {};
    
    console.log(`User has ${likesSnap.size} likes in their collection`);
    
    // Count likes for each post by checking posts/{postId}/likes subcollections
    const postsRef = collection(db, 'posts');
    const postsSnap = await getDocs(postsRef);
    
    for (const postDoc of postsSnap.docs) {
      const postId = postDoc.id;
      const likesSubRef = collection(db, 'posts', postId, 'likes');
      const likesSubSnap = await getDocs(likesSubRef);
      likeCounts[postId] = likesSubSnap.size;
      
      // Check if current user liked this post
      const userLikeDoc = likesSubSnap.docs.find(doc => doc.id === user.uid);
      if (userLikeDoc) {
        userLikes.add(postId);
      }
    }
    
    // Also check likes for sample threads (local data)
    for (const thread of threads) {
      if (!likeCounts[thread.id]) {
        const likesSubRef = collection(db, 'posts', thread.id, 'likes');
        const likesSubSnap = await getDocs(likesSubRef);
        likeCounts[thread.id] = likesSubSnap.size;
        
        const userLikeDoc = likesSubSnap.docs.find(doc => doc.id === user.uid);
        if (userLikeDoc) {
          userLikes.add(thread.id);
        }
      }
    }
    
    console.log('Likes loaded:', Array.from(userLikes));
    console.log('Like counts:', likeCounts);
  } catch (e) {
    console.error('Failed to load user likes', e);
    userLikes.clear();
    likeCounts = {};
  }
}

// Load current user's follow status from Firestore
async function loadUserFollows() {
  try {
    const user = auth.currentUser;
    if (!user) {
      followStatus = {};
      return;
    }
    
    // Load user's followed authors
    const followsRef = collection(db, 'users', user.uid, 'follows');
    const followsSnap = await getDocs(followsRef);
    followStatus = {};
    
    followsSnap.docs.forEach(docSnap => {
      const authorName = docSnap.id; // Document ID is the author name
      followStatus[authorName] = true;
    });
    
    console.log('Follows loaded:', followStatus);
  } catch (e) {
    console.error('Failed to load user follows', e);
    followStatus = {};
  }
}

// Load current user's bookmark status from Firestore
async function loadUserBookmarks() {
  try {
    const user = auth.currentUser;
    if (!user) {
      bookmarkStatus = {};
      return;
    }
    
    // Load user's bookmarked posts
    const bookmarksRef = collection(db, 'users', user.uid, 'bookmarks');
    const bookmarksSnap = await getDocs(bookmarksRef);
    bookmarkStatus = {};
    
    bookmarksSnap.docs.forEach(docSnap => {
      const postId = docSnap.id; // Document ID is the post ID
      bookmarkStatus[postId] = true;
    });
    
    console.log('Bookmarks loaded:', bookmarkStatus);
  } catch (e) {
    console.error('Failed to load user bookmarks', e);
    bookmarkStatus = {};
  }
}

function renderOne(thread) {
  const postElement = document.createElement('div');
  postElement.className = 'instagram-post fade-in';
  postElement.id = `post-${thread.id}`;
  
  // Use Firestore like status if available, fallback to localStorage
  const isLikedByUser = userLikes.has(thread.id);
  const likeCount = likeCounts[thread.id] || 0;
  const isFollowing = followStatus[thread.author] || false;
  const isBookmarked = bookmarkStatus[thread.id] || false;
    
    postElement.innerHTML = `
      <div class="post-header">
        <div class="user-info">
          <div class="avatar">${thread.author.charAt(0).toUpperCase()}</div>
          <div class="user-details">
            <span class="username">${thread.author}</span>
            <span class="location">Community</span>
          </div>
        </div>
        <div class="post-actions">
          <button class="follow-btn ${isFollowing ? 'following' : ''}" data-user="${thread.author}">
            <i class="bi bi-${isFollowing ? 'person-check-fill' : 'person-plus'}"></i>
            ${isFollowing ? 'Following' : 'Follow'}
          </button>
          <button class="more-btn">
            <i class="bi bi-three-dots"></i>
          </button>
        </div>
      </div>
      
      <div class="post-image">
        ${thread.mediaUrl ? `<img src="${thread.mediaUrl}" alt="post" class="w-100" style="height:400px;object-fit:cover;">` : '<div class="image-placeholder"></div>'}
      </div>
      
      <div class="post-actions-bar">
        <div class="action-buttons">
          <button class="action-btn like-btn ${isLikedByUser ? 'liked' : ''}" data-post-id="${thread.id}">
            <i class="bi bi-heart${isLikedByUser ? '-fill' : ''}"></i>
          </button>
          <button class="action-btn comment-btn" data-post-id="${thread.id}">
            <i class="bi bi-chat"></i>
          </button>
          <button class="action-btn share-btn">
            <i class="bi bi-send"></i>
          </button>
        </div>
        <button class="action-btn bookmark-btn ${isBookmarked ? 'bookmarked' : ''}" data-post-id="${thread.id}">
          <i class="bi bi-bookmark${isBookmarked ? '-fill' : ''}"></i>
        </button>
      </div>
      
      <div class="post-stats">
        <div class="like-count">${likeCount} ${likeCount === 1 ? 'like' : 'likes'}</div>
        <div class="comment-count">${thread.comments.length} ${thread.comments.length === 1 ? 'comment' : 'comments'}</div>
      </div>
      
      <div class="post-caption">
        <span class="username">${thread.author}</span>
        <span class="caption">${thread.content || 'Beautiful moment captured! âœ¨'}</span>
      </div>
      
      <div class="comments-section" id="comments-${thread.id}" style="display: none;">
        <div class="comments-list">
          ${thread.comments.map((comment, commentIndex) => `
            <div class="comment-item" data-comment-index="${commentIndex}">
              <div class="comment-content">
                <span class="comment-author">${comment.author}</span>
                <span class="comment-text">${comment.content}</span>
              </div>
              <div class="comment-actions">
                <button class="comment-like-btn">
                  <i class="bi bi-heart"></i>
                </button>
                ${comment.author === "You" ? `<button class="delete-comment-btn"><i class="bi bi-trash"></i></button>` : ''}
              </div>
            </div>
          `).join('')}
        </div>
        
        <div class="add-comment">
          <input type="text" placeholder="Add a comment..." class="comment-input" data-post-id="${thread.id}" />
          <button class="post-comment-btn" data-post-id="${thread.id}">
            <i class="bi bi-send"></i>
          </button>
        </div>
      </div>
    `;
    
  feed.appendChild(postElement);
  setupPostInteractions(postElement, thread);
}

function setupPostInteractions(postElement, thread) {
  // Like functionality
  const likeBtn = postElement.querySelector('.like-btn');
  const likeCount = postElement.querySelector('.like-count');
  
  likeBtn.addEventListener('click', async function() {
    const postId = thread.id;
    const isLiked = this.classList.contains('liked');
    
    // Update UI immediately
    if (isLiked) {
      likeCounts[postId] = Math.max(0, (likeCounts[postId] || 0) - 1);
      this.classList.remove('liked');
      this.querySelector('i').className = 'bi bi-heart';
      userLikes.delete(postId);
    } else {
      likeCounts[postId] = (likeCounts[postId] || 0) + 1;
      this.classList.add('liked');
      this.querySelector('i').className = 'bi bi-heart-fill';
      this.style.animation = 'heartPulse 0.6s ease-in-out';
      setTimeout(() => this.style.animation = '', 600);
      userLikes.add(postId);
    }
    
    // Don't save to localStorage anymore - counts are managed in Firestore
    likeCount.textContent = `${likeCounts[postId]} ${likeCounts[postId] === 1 ? 'like' : 'likes'}`;

    // Sync to Firestore likes so it appears in Profile > Liked
    if (window.__likeSync) {
      const op = isLiked ? window.__likeSync.unsetUserLike : window.__likeSync.setUserLike;
      const snapshot = { authorName: thread.author, caption: thread.content || '', mediaUrl: thread.mediaUrl || null };
      try {
        await op(postId, snapshot);
      } catch (e) {
        if (e && e.message === 'not-authenticated') {
          alert('Please sign in to like posts.');
          // Revert UI changes
          if (isLiked) {
            likeCounts[postId] = (likeCounts[postId] || 0) + 1;
            this.classList.add('liked');
            this.querySelector('i').className = 'bi bi-heart-fill';
            userLikes.add(postId);
          } else {
            likeCounts[postId] = Math.max(0, (likeCounts[postId] || 0) - 1);
            this.classList.remove('liked');
            this.querySelector('i').className = 'bi bi-heart';
            userLikes.delete(postId);
          }
          likeCount.textContent = `${likeCounts[postId]} ${likeCounts[postId] === 1 ? 'like' : 'likes'}`;
        } else {
          console.error('Like sync failed', e);
        }
      }
    }
  });
  
  // Follow functionality
  const followBtn = postElement.querySelector('.follow-btn');
  followBtn.addEventListener('click', async function() {
    const authorName = this.dataset.user;
    const isFollowing = this.classList.contains('following');
    const currentUser = auth.currentUser;
    
    if (!currentUser) {
      alert('Please sign in to follow users.');
      return;
    }
    
    try {
      if (isFollowing) {
        // Unfollow: remove from Firestore
        await deleteDoc(doc(db, 'users', currentUser.uid, 'follows', authorName));
        followStatus[authorName] = false;
        this.classList.remove('following');
        this.innerHTML = '<i class="bi bi-person-plus"></i> Follow';
      } else {
        // Follow: add to Firestore
        await setDoc(doc(db, 'users', currentUser.uid, 'follows', authorName), {
          authorName: authorName,
          followedAt: new Date()
        });
        followStatus[authorName] = true;
        this.classList.add('following');
        this.innerHTML = '<i class="bi bi-person-check-fill"></i> Following';
      }
    } catch (e) {
      console.error('Follow action failed', e);
      alert('Could not update follow status. Please try again.');
    }
  });
  
  // Bookmark functionality
  const bookmarkBtn = postElement.querySelector('.bookmark-btn');
  bookmarkBtn.addEventListener('click', async function() {
    const postId = thread.id;
    const isBookmarked = this.classList.contains('bookmarked');
    const currentUser = auth.currentUser;
    
    if (!currentUser) {
      alert('Please sign in to bookmark posts.');
      return;
    }
    
    try {
      if (isBookmarked) {
        // Remove bookmark from Firestore
        await deleteDoc(doc(db, 'users', currentUser.uid, 'bookmarks', postId));
        bookmarkStatus[postId] = false;
        this.classList.remove('bookmarked');
        this.querySelector('i').className = 'bi bi-bookmark';
      } else {
        // Add bookmark to Firestore
        await setDoc(doc(db, 'users', currentUser.uid, 'bookmarks', postId), {
          postId: postId,
          bookmarkedAt: new Date(),
          authorName: thread.author,
          caption: thread.content || '',
          mediaUrl: thread.mediaUrl || null
        });
        bookmarkStatus[postId] = true;
        this.classList.add('bookmarked');
        this.querySelector('i').className = 'bi bi-bookmark-fill';
      }
    } catch (e) {
      console.error('Bookmark action failed', e);
      alert('Could not update bookmark status. Please try again.');
    }
  });
  
  // Comment toggle
  const commentBtn = postElement.querySelector('.comment-btn');
  const commentsSection = postElement.querySelector('.comments-section');
  const commentCount = postElement.querySelector('.comment-count');
  
  commentBtn.addEventListener('click', function() {
    const isVisible = commentsSection.style.display !== 'none';
    commentsSection.style.display = isVisible ? 'none' : 'block';
    this.classList.toggle('active');
  });
  
  // Add comment functionality
  const commentInput = postElement.querySelector('.comment-input');
  const postCommentBtn = postElement.querySelector('.post-comment-btn');
  
  function addComment() {
    const commentText = commentInput.value.trim();
    if (!commentText) return;
    
    thread.comments.push({author: 'You', date: Date.now(), content: commentText});
    localStorage.setItem('threads', JSON.stringify(threads));
    
    const commentsList = postElement.querySelector('.comments-list');
    const newComment = document.createElement('div');
    newComment.className = 'comment-item';
    newComment.innerHTML = `
      <div class="comment-content">
        <span class="comment-author">You</span>
        <span class="comment-text">${commentText}</span>
      </div>
      <div class="comment-actions">
        <button class="comment-like-btn">
          <i class="bi bi-heart"></i>
        </button>
        <button class="delete-comment-btn">
          <i class="bi bi-trash"></i>
        </button>
      </div>
    `;
    
    commentsList.appendChild(newComment);
    commentInput.value = '';
    commentCount.textContent = `${thread.comments.length} ${thread.comments.length === 1 ? 'comment' : 'comments'}`;
    
    // Setup new comment interactions
    setupCommentInteractions(newComment, thread);
  }
  
  postCommentBtn.addEventListener('click', addComment);
  commentInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') addComment();
  });
  
  // Setup existing comment interactions
  postElement.querySelectorAll('.comment-item').forEach(commentItem => {
    setupCommentInteractions(commentItem, thread);
  });
}

function setupCommentInteractions(commentItem, thread) {
  // Comment like functionality
  const commentLikeBtn = commentItem.querySelector('.comment-like-btn');
  commentLikeBtn.addEventListener('click', function() {
    this.classList.toggle('liked');
    const icon = this.querySelector('i');
    icon.className = this.classList.contains('liked') ? 'bi bi-heart-fill' : 'bi bi-heart';
  });
  
  // Delete comment functionality
  const deleteBtn = commentItem.querySelector('.delete-comment-btn');
  if (deleteBtn) {
    deleteBtn.addEventListener('click', function() {
      const commentIndex = parseInt(commentItem.dataset.commentIndex);
      thread.comments.splice(commentIndex, 1);
      localStorage.setItem('threads', JSON.stringify(threads));
      commentItem.remove();
      
      // Update comment count
      const postElement = commentItem.closest('.instagram-post');
      const commentCount = postElement.querySelector('.comment-count');
      commentCount.textContent = `${thread.comments.length} ${thread.comments.length === 1 ? 'comment' : 'comments'}`;
    });
  }
}

// Search functionality
document.getElementById('searchInput').addEventListener('input', function() {
  const searchTerm = this.value.toLowerCase();
  const posts = document.querySelectorAll('.instagram-post');
  
  posts.forEach(post => {
    const username = post.querySelector('.username').textContent.toLowerCase();
    const caption = post.querySelector('.caption').textContent.toLowerCase();
    const isVisible = username.includes(searchTerm) || caption.includes(searchTerm);
    post.style.display = isVisible ? 'block' : 'none';
  });
});

// Initialize the feed AFTER auth is ready
// This ensures likes/follows/bookmarks load correctly
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";

let feedInitialized = false;

onAuthStateChanged(getAuth(), async (user) => {
  if (!feedInitialized) {
    feedInitialized = true;
    // Auth state is now ready (user logged in or not)
    // Now we can safely load likes and render the feed
    await renderInstagramFeed();
  }
});
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
